package forge.gui;

import forge.util.ThreadUtil;

public class FThreads {
    private FThreads() { } // no instances supposed

    /** Checks if calling method uses event dispatch thread.
     * Exception thrown if method is on "wrong" thread.
     * A boolean is passed to indicate if the method must be EDT or not.
     *
     * @param methodName &emsp; String, part of the custom exception message.
     * @param mustBeEDT &emsp; boolean: true = exception if not EDT, false = exception if EDT
     */
    public static void assertExecutedByEdt(final boolean mustBeEDT) {
        if (GuiBase.isNetworkplay())
            return; //don't check for networkplay
        if (isGuiThread() != mustBeEDT) {
            final StackTraceElement[] trace = Thread.currentThread().getStackTrace();
            final String methodName = trace[2].getClassName() + "." + trace[2].getMethodName();
            final String modalOperator = mustBeEDT ? " must be" : " may not be";
            throw new IllegalStateException(methodName + modalOperator + " accessed from the event dispatch thread.");
        }
    }

    public static void invokeInEdtLater(final Runnable proc) {
        GuiBase.getInterface().invokeInEdtLater(proc);
    }

    public static void invokeInEdtNowOrLater(final Runnable proc) {
        if (isGuiThread()) {
            GuiBase.getInterface().invokeInEdtNow(proc);
        } else {
            GuiBase.getInterface().invokeInEdtLater(proc);
        }
    }

    /**
     * Invoke the given Runnable in an Event Dispatch Thread and wait for it to
     * finish; but <B>try to use SwingUtilities.invokeLater instead whenever
     * feasible.</B>
     *
     * Exceptions generated by SwingUtilities.invokeAndWait (if used), are
     * rethrown as RuntimeExceptions.
     *
     * @param proc
     *            the Runnable to run
     * @see fgd.SwingUtilities#invokeLater(Runnable)
     */
    public static void invokeInEdtAndWait(final Runnable proc) {
        GuiBase.getInterface().invokeInEdtAndWait(proc);
    }

    private static int backgroundThreadCount;
    public static void invokeInBackgroundThread(final Runnable proc) {
        //start thread name with "Game" so isGuiThread() returns false on GuiMobile
        new Thread(proc, "Game BT" + backgroundThreadCount).start();
        backgroundThreadCount++;
    }

    public static boolean isGuiThread() {
        return GuiBase.getInterface().isGuiThread();
    }

    public static void delayInEDT(final int milliseconds, final Runnable inputUpdater) {
        final Runnable runInEdt = () -> FThreads.invokeInEdtNowOrLater(inputUpdater);
        ThreadUtil.delay(milliseconds, runInEdt);
    }

    public static String debugGetCurrThreadId() {
        return isGuiThread() ? "EDT" : Thread.currentThread().getName();
    }

    public static String debugGetStackTraceItem(final int depth, final boolean shorter) {
        final StackTraceElement[] trace = Thread.currentThread().getStackTrace();
        String lastItem = trace[depth].toString();
        if (shorter) {
            int lastPeriod = lastItem.lastIndexOf('.');
            lastPeriod = lastItem.lastIndexOf('.', lastPeriod-1);
            lastPeriod = lastItem.lastIndexOf('.', lastPeriod-1);
            lastItem = lastItem.substring(lastPeriod+1);
            return String.format("%s > from %s", debugGetCurrThreadId(), lastItem);
        }
        return String.format("%s > %s called from %s", debugGetCurrThreadId(),
                trace[2].getClassName() + "." + trace[2].getMethodName(), lastItem);
    }

    public static String debugGetStackTraceItem(final int depth) {
        return debugGetStackTraceItem(depth, false);
    }
}
